package com.androidsdk.snaphy.snaphyandroidsdk.repository;
<%
    function capitalizeFirstLetter(string) {

        return string.charAt(0).toUpperCase() + string.slice(1);
    }

    function lowercaseFirstLetter(string) {

        return string.charAt(0).toLowerCase() + string.slice(1);
    }

    //convert javascript to java type
    function convertType(type, model){
        if(type === "string" || type === "any"){
            return "String";
        }
        else if (type === "number") {
            return "Double";
        }
        else if (type === "object") {
            return "HashMap<String, Object>"
        }
        else if (type === "boolean") {
            return "Boolean"
        }
        else {

            return capitalizeFirstLetter(checkTypeConversion(type, model));
        }
    }

    //check special type conversion for models with hasAndBelongsToMany relations ..
    function checkTypeConversion(type, model){

        //Convert type for hasAndBelongsToMany type like type CategoryRecipe  = Recipe or Category <--- type remove which belongs to current model. of the repo
        if(model.allDef[type] === undefined){
            //Check by removing the model..
            var patt = new RegExp("^" + capitalizeFirstLetter(model.name) );
            var newType = type.replace(patt, "");

            if(model.allDef[newType] !== undefined){
                //Then add this model to new type..
                type = newType;
            }else{
                //Check by removing the model..
                var patt = new RegExp(capitalizeFirstLetter(model.name) + "$" );
                newType = type.replace(patt, "");
                if(model.allDef[newType] !== undefined){
                    //Then add this model to new type..
                    type = newType;
                }
            }
            return type;
        }else{
            return type;
        }
    }


    //isInternalArgument function function for finding if an argument is internal or not..
    function  isInternalArgument(argumentObj, argumentName, method){
        var argumentSource = argumentObj.http.source;
        var internalArgument = false;
        //Now check if the argument is the internal argument..
        if(argumentSource === "path"){
            //Now check if the argument does not belongs to related mode data..
            if(method.hasResourceParams){
                var argumentFound = false;
                for(var i=0; i< method.resourceParams.length; i++){
                    var resourceArgObj = method.resourceParams[i];
                    if(resourceArgObj.arg === argumentName){
                        argumentFound = true;
                        break;
                    }
                } //forloop ends
                if(argumentFound){
                    internalArgument = false;
                }else{
                    internalArgument = true;
                }
            }else{
                //Argument is internal argument..
                internalArgument = true;
            }
        } //if path
        return internalArgument;
    }

    var modelName = capitalizeFirstLetter(model.name);
%>


import com.google.common.collect.ImmutableMap;
import com.strongloop.android.loopback.callbacks.ListCallback;
import com.strongloop.android.loopback.callbacks.ObjectCallback;
import com.strongloop.android.loopback.callbacks.VoidCallback;
import com.strongloop.android.remoting.JsonUtil;
import com.strongloop.android.remoting.adapters.Adapter;
import com.strongloop.android.remoting.adapters.RestContract;
import com.strongloop.android.remoting.adapters.RestContractItem;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;


<% if(model.base === "User" || modelName === "User"){ %>
import com.strongloop.android.loopback.UserRepository;
import com.strongloop.android.loopback.AccessTokenRepository;
import com.strongloop.android.loopback.AccessToken;
<% } else { %>
import com.strongloop.android.loopback.ModelRepository;
<% } %>


import org.json.JSONArray;
import org.json.JSONObject;

//Import its models too.
import com.androidsdk.snaphy.snaphyandroidsdk.models.<%- modelName %>;

//Now import model of related models..
<% for(relation in model.relations) { %>
    <% if(model.relations.hasOwnProperty(relation)) {
        if(model.allDef[model.relations[relation].model] !== undefined){
            var relatedModelName = model.relations[relation].model;
            var modelName_ = capitalizeFirstLetter(relatedModelName) ;
    %>
            import com.androidsdk.snaphy.snaphyandroidsdk.models.<%- modelName_ %>;
            import com.androidsdk.snaphy.snaphyandroidsdk.repository.<%- modelName_ %>Repository;
            <% if( model.relations[relation].through) {
                var throughModel = model.relations[relation].through;
            %>
                import com.androidsdk.snaphy.snaphyandroidsdk.models.<%- throughModel %>;
                import com.androidsdk.snaphy.snaphyandroidsdk.repository.<%- throughModel %>Repository;
            <% } %>
        <% } %>
    <% } %>
<% } %>



<% if(model.base === "User" || modelName === "User"){ %>
public class <%- modelName %>Repository extends com.strongloop.android.loopback.UserRepository<<%- modelName %>> {
<% } else { %>
public class <%- modelName %>Repository extends ModelRepository<<%- modelName %>> {
<% } %>

    public <%- modelName %>Repository(){
        super("<%- modelName %>", null, <%- modelName %>.class);
    }





    public RestContract createContract() {
        RestContract contract = super.createContract();
        <% model.restDefinition.methods.forEach(function(restMethodObj){
            var patt = new RegExp("^" + model.name + "\\..+");
            var routeMethod = restMethodObj.routes[0].verb.toUpperCase();
            if(routeMethod === "DEL"){
                routeMethod = "DELETE"
            }
            if(routeMethod === "ALL"){
                routeMethod = "POST"
            }
        %>
            <% if(restMethodObj.fullName
                && patt.test(restMethodObj.fullName)
                && restMethodObj.name !== "createChangeStream"
                && restMethodObj.name !== "login"
                && restMethodObj.name !== "logout"
                && restMethodObj.name !== "save" ){
            %>
                contract.addItem(new RestContractItem("/" + getNameForRestUrl() + "<%- restMethodObj.routes[0].path %>", "<%- routeMethod %>"), "<%- restMethodObj.fullName %>");
            <% } %>
        <% });%>
        return contract;
    }



    <%#{
        "fullName": "Recipe.prototype.__get__customer",
        "name": "prototype.__get__customer",
        "accepts": [{
            "arg": "id",
            "type": "any",
            "required": true,
            "http": {
                "source": "path"
            },
            "description": "PersistedModel id"
        }, {
            "arg": "refresh",
            "type": "boolean",
            "http": {
                "source": "query"
            }
        }],
        "returns": [{
            "arg": "customer",
            "type": "Customer",
            "root": true
        }],
        "errors": [],
        "description": "Fetches belongsTo relation customer.",
        "documented": true,
        "routes": [{
            "path": "/:id/customer",
            "verb": "get"
        }],
        "internal": "Use Recipe.customer() instead."
      } %>




    <% model.restDefinition.methods.forEach(function(restMethodObj){
        var patt = new RegExp("^" + model.name + "\\..+");
        //metch prototype.__
        var methodPatt = /prototype\.\_?\_?/;
    %>
        <% if(restMethodObj.fullName
            && patt.test(restMethodObj.fullName)
            && restMethodObj.name !== "createChangeStream"
            && restMethodObj.name !== "login"
            && restMethodObj.name !== "logout"
            && restMethodObj.name !== "save" ){

            var restMethodName = restMethodObj.name.replace(methodPatt, "");
            var methodString = "public void ";
            methodString = methodString + restMethodName + "( ";
            //ImmutableMap string concatenation..
            var mapString = "ImmutableMap.of(";
            var totalArgument = 0;
            //Now loop through all the required arguments..
            restMethodObj.accepts.forEach(function(requiredArgumentObj, index){
                var type            = requiredArgumentObj.type;
                var argumentName    = requiredArgumentObj.arg;
                if(type instanceof Array){
                    type = "List<" + convertType(type[0], model) + ">" ;
                }else{
                    type = convertType(type, model);
                }

                //Convert type for hasAndBelongsToMany type like type CategoryRecipe  = Recipe or Category <--- type remove which belongs to current model. of the repo
                if(model.allModels[type] === undefined){
                    //Check by removing the model..
                    var patt = new RegExp("^" + capitalizeFirstLetter(model.name) );
                    var newType = type.replace(patt, "");

                    if(model.allModels[newType] !== undefined){
                        //Then add this model to new type..
                        type = newType;
                    }else{
                        //Check by removing the model..
                        var patt = new RegExp(capitalizeFirstLetter(model.name) + "$" );
                        newType = type.replace(patt, "");
                        if(model.allModels[newType] !== undefined){
                            //Then add this model to new type..
                            type = newType;
                        }
                    }
                }

                totalArgument ++;
                //ImmutableMap of mapping data..
                if(index === 0){
                    mapString = mapString + '"' + argumentName + '"' +  ', ' + argumentName ;
                }else{
                    mapString = mapString + ', "' + argumentName + '"' +  ', ' + argumentName ;
                }
                methodString = methodString + " " + type + " " + argumentName + ", ";
            });

            //If no argument is required then add null type..
            if(totalArgument !== 0){
                //Wrapup ImmutableMap data..
                mapString  = mapString + ")";
            }else{
                mapString  = "null";
            }



            //Now get the return type....
            var callback ;
            var returnType;
            var callbackType;
            //Type name like String etc..
            var type;
            var method = restMethodObj;
            if(method.returns.length && Object.keys(method.returns[0]).length !== 0){
                if(method.returns[0].type instanceof Array){
                    type = convertType(method.returns[0].type[0], model);
                    if(model.allModels[type] !== undefined){
                        returnType = "List<" + type + ">";
                        methodString = methodString  +  "final ListCallback<" + type + "> callback)";
                        callback = "ListCallback<" + type + "> ";
                        callbackType = "ListCallback";
                    }else{
                        returnType = type;
                        methodString = methodString  +  "final Adapter.JsonArrayCallback callback)";
                        //methodString = methodString  +  "final ObjectCallback<" + type + "> callback)";
                        callback = "new Adapter.JsonArrayCallback()";
                        callbackType = "ListCallback";
                    }
                }else{

                    type = convertType(method.returns[0].type, model);
                    if(model.allModels[type] !== undefined){
                        returnType = type;
                        methodString = methodString  +  "final ObjectCallback<" + type + "> callback)";
                        callback = "ObjectCallback<" + type + "> ";
                        callbackType = "ObjectCallback";
                    }else{
                        returnType = type;

                        methodString = methodString + "final Adapter.JsonObjectCallback  callback )";
                        //methodString = methodString  +  "final ObjectCallback<" + type + "> callback)";
                        callback = "new Adapter.JsonObjectCallback()";
                        //callback = "ObjectCallback<" + type + "> ";
                        callbackType = "ObjectCallback";
                    }

                }
            }else{
                methodString = methodString  +  "final VoidCallback callback)";
                callback = "VoidCallback ";
                //returnType = type;
                callbackType = "VoidCallback";
            }

        %>
            //Method <%- restMethodName %> definition
            <%- methodString %>{
                <% if(callbackType === "VoidCallback") {%>
                    invokeStaticMethod("<%- restMethodObj.name %>", <%- mapString %>, new Adapter.Callback() {
                        @Override
                        public void onError(Throwable t) {
                            callback.onError(t);
                        }

                        @Override
                        public void onSuccess(String response) {
                            callback.onSuccess();
                        }
                    });
                <% } %>


                <% if(callbackType === "ObjectCallback") {%>
                    <% if(model.allModels[type] === undefined) { %>
                    invokeStaticMethod("<%- restMethodObj.name %>", <%- mapString %>, new Adapter.JsonObjectCallback() {
                    <% } %>
                    <% if(model.allModels[type] !== undefined) { %>
                    invokeStaticMethod("<%- restMethodObj.name %>", <%- mapString %>, new Adapter.JsonObjectCallback() {
                    <% } %>
                        @Override
                        public void onError(Throwable t) {
                            callback.onError(t);
                        }

                        @Override
                        public void onSuccess(JSONObject response) {
                            <% if(model.allModels[type] === undefined) { %>
                                callback.onSuccess(response);
                            <% }else{ %>
                                if(responce != null){
                                    <%- type %>Repository <%- lowercaseFirstLetter(type) %>Repo = getRestAdapter().createRepository(<%- type %>Repository.class);
                                    Map<String, Object> result = JsonUtil.fromJson(response);
                                    <%- type %> <%- lowercaseFirstLetter(type) %> = <%- lowercaseFirstLetter(type) %>Repo.createObject(result);
                                    callback.onSuccess(<%- lowercaseFirstLetter(type) %>);

                                }else{
                                    callback.onSuccess(null);
                                }
                            <% } %>
                        }
                    });
                <% } %>

                <% if(callbackType === "ListCallback") {%>
                    invokeStaticMethod("<%- restMethodObj.name %>", <%- mapString %>, new Adapter.JsonArrayCallback() {
                        @Override
                        public void onError(Throwable t) {
                            callback.onError(t);
                        }

                        @Override
                        public void onSuccess(JSONArray response) {
                            <% if(model.allModels[type] === undefined) { %>
                                callback.onSuccess(response);
                            <% }else{ %>
                                if(response != null){
                                    //Now converting jsonObject to list
                                    List<Map<String, Object>> result = (List) JsonUtil.fromJson(response);
                                    List<<%- type %>> <%- lowercaseFirstLetter(type) %>List = new ArrayList<<%- type %>>();
                                    <%- type %>Repository <%- lowercaseFirstLetter(type) %>Repo = getRestAdapter().createRepository(<%- type %>Repository.class);

                                    for (Map<String, Object> obj : result) {
                                        <%- type %> <%- lowercaseFirstLetter(type) %> = <%- lowercaseFirstLetter(type) %>Repo.createObject(obj);
                                        <%- lowercaseFirstLetter(type) %>List.add(<%- lowercaseFirstLetter(type) %>);
                                    }
                                    callback.onSuccess(<%- lowercaseFirstLetter(type) %>List);
                                }else{
                                    callback.onSuccess(null);
                                }
                            <% } %>
                        }
                    });
                <% } %>

            }//Method <%- restMethodName %> definition ends here..

            <%# //Now add methods for each restMethods..
            public void get__customer(String id, final ObjectCallback<Customer> callback) {
                invokeStaticMethod("prototype.__get__customer", ImmutableMap.of("id", id), new Adapter.JsonObjectCallback() {
                    @Override
                    public void onSuccess(JSONObject response) {
                        CustomerRepository responseCustomerRepository = new CustomerRepository();
                        Customer  customer = response != null
                                ? responseCustomerRepository.createObject(JsonUtil.fromJson(response))
                                : null;
                        //List<Order> customerList ;
                        callback.onSuccess(customer);
                    }

                    @Override
                    public void onError(Throwable t) {
                        callback.onError(t);
                    }
                });

            }%>

        <% } %>
    <% });%>



}
