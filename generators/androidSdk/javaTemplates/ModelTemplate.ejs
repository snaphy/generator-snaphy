package com.androidsdk.snaphy.snaphyandroidsdk.models;

<%
    function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

    function lowercaseFirstLetter(string) {
        return string.charAt(0).toLowerCase() + string.slice(1);
    }

    //convert javascript to java type
    function convertType(type, model){
        if(type === "string" || type === "any"){
            return "String";
        }
        else if (type === "number") {
            return "double";
        }
        else if (type === "object") {
            return "Map<String,  ? extends Object>"
        }
        else if (type === "boolean") {
            return "Boolean"
        }
        else if(type === "geopoint"){
            return "Map<String, Object>"
        }
        else {

            return capitalizeFirstLetter(checkTypeConversion(type, model));
        }
    }


    //Return if type belongs to like CustomerRecipe or RecipeCustomer
    function checkHasAndBelongsToDataType(type, model){
        var hasAndBelongsToMany = false;
        if(model.restDefinition[type] === undefined){
            //Check by removing the model..
            var patt = new RegExp("^" + capitalizeFirstLetter(model.name) );
            var newType = type.replace(patt, "");

            if(model.restDefinition[newType] !== undefined){
                //Then add this model to new type..
                hasAndBelongsToMany = true;
            }else{
                //Check by removing the model..
                var patt = new RegExp(capitalizeFirstLetter(model.name) + "$" );
                newType = type.replace(patt, "");
                if(model.restDefinition[newType] !== undefined){
                    //Then add this model to new type..
                    hasAndBelongsToMany = true;
                }
            }
            return hasAndBelongsToMany;
        }else{
            hasAndBelongsToMany = false;
            return hasAndBelongsToMany;
        }
    }

    //check special type conversion for models with hasAndBelongsToMany relations ..
    function checkTypeConversion(type, model){

        //Convert type for hasAndBelongsToMany type like type CategoryRecipe  = Recipe or Category <--- type remove which belongs to current model. of the repo
        if(model.restDefinition[type] === undefined){
            //Check by removing the model..
            var patt = new RegExp("^" + capitalizeFirstLetter(model.name) );
            var newType = type.replace(patt, "");

            if(model.restDefinition[newType] !== undefined){
                //Then add this model to new type..
                type = newType;
            }else{
                //Check by removing the model..
                var patt = new RegExp(capitalizeFirstLetter(model.name) + "$" );
                newType = type.replace(patt, "");
                if(model.restDefinition[newType] !== undefined){
                    //Then add this model to new type..
                    type = newType;
                }
            }
            return type;
        }else{
            return type;
        }
    }


    //isInternalArgument function function for finding if an argument is internal or not..
    function  isInternalArgument(argumentObj, argumentName, method){

        var argumentSource;
        if(argumentObj.http !== undefined){
            argumentSource = argumentObj.http.source;
        }else{
            argumentSource = null;
        }

        if(argumentSource === null){
            return false;
        }

        var internalArgument = false;
        //Now check if the argument is the internal argument..
        if(argumentSource === "path"){
            //Now check if the argument does not belongs to related mode data..
            if(method.hasResourceParams){
                var argumentFound = false;
                for(var i=0; i< method.resourceParams.length; i++){
                    var resourceArgObj = method.resourceParams[i];
                    if(resourceArgObj.arg === argumentName){
                        argumentFound = true;
                        break;
                    }
                } //forloop ends
                if(argumentFound){
                    internalArgument = false;
                }else{
                    internalArgument = true;
                }
            }else{
                //Argument is internal argument..
                internalArgument = true;
            }
        } //if path
        return internalArgument;
    }

    var modelName = capitalizeFirstLetter(model.name);
%>



<%
/*
if(model.base === "User" || modelName === "User"){ %>
import com.strongloop.android.loopback.User;
<% } else { %>

   import com.strongloop.android.loopback.Model;
<% }
*/
%>

import org.json.JSONObject;
import org.json.JSONArray;

import java.util.List;
import com.strongloop.android.loopback.RestAdapter;
import com.strongloop.android.remoting.adapters.Adapter;

/*
Replacing with custom Snaphy callback methods
import com.strongloop.android.loopback.callbacks.ListCallback;
import com.strongloop.android.loopback.callbacks.ObjectCallback;
import com.strongloop.android.loopback.callbacks.VoidCallback;
*/
import com.androidsdk.snaphy.snaphyandroidsdk.callbacks.ObjectCallback;
import com.androidsdk.snaphy.snaphyandroidsdk.callbacks.DataListCallback;
import com.androidsdk.snaphy.snaphyandroidsdk.callbacks.VoidCallback;
import com.androidsdk.snaphy.snaphyandroidsdk.list.DataList;

//Import self repository..
import com.androidsdk.snaphy.snaphyandroidsdk.repository.<%- modelName %>Repository;

//Now import repository of related models..
<% for(relation in model.relations) { %>
    <% if(model.relations.hasOwnProperty(relation)) {
        if(model.restDefinition[model.name] !== undefined && model.relations[relation].model !== "AccessToken"){
            var relatedModelName = model.relations[relation].model;
            var repoName = capitalizeFirstLetter(relatedModelName) + "Repository";

    %>
            import com.androidsdk.snaphy.snaphyandroidsdk.repository.<%- repoName %>;
            <% if( model.relations[relation].through) {
                var throughModel = model.relations[relation].through;
            %>
                import com.androidsdk.snaphy.snaphyandroidsdk.models.<%- throughModel %>;
                import com.androidsdk.snaphy.snaphyandroidsdk.repository.<%- throughModel %>Repository;
            <% } %>

        <% } %>
    <% } %>
<% } %>

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;


<% if(model.base === "User" || modelName === "User"){ %>
public class <%- modelName %> extends User {
<% } else { %>
public class <%- modelName %> extends Model {
<% } %>

    //For converting all model values to hashMap
    private  transient Map<String, Object> hashMap = new HashMap<>();

    public Map<String,  ? extends Object> convertMap(){
        if(that.getId() != null){
            return hashMap;
        }else{
            hashMap.put("id", that.getId());
            return hashMap;
        }
    }

    private <%- modelName %> that ;

    public <%- modelName %> (){
        that = this;
    }

    <% for( var property in model.properties) { %>
        <% if(model.properties.hasOwnProperty(property)){
            var capitalPropertyName = capitalizeFirstLetter(property);
            var isArray = model.properties[property].type instanceof Array;
        %>
            <% if(isArray) {
                  var typeName = model.properties[property].type[0];
                  var listType;
                  if(typeName === "object" || typeName === "geopoint"){
                      listType = "DataList<Map<String, Object>>";
                  }
                  else if (typeName === "string" || typeName === "date") {
                      listType = "DataList<String>";
                  }
                  else if (typeName === "number") {
                      listType = "DataList<Double>";
                  }
                  else{
                      listType = "DataList<Object>";
                  }
            %>

                private <%- listType %> <%- property %>;
                /* Adding Getter and Setter methods */
                public <%- listType %> get<%- capitalPropertyName %>(){
                    return <%- property %>;
                }

                /* Adding Getter and Setter methods */
                public void set<%- capitalPropertyName %>(<%- listType %> <%- property %>){
                    this.<%- property %> = <%- property %>;

                    //TODO change this to custom array with double quotes escaped if error occured when sending to server..
                    hashMap.put("<%- property %>", <%- property %>);
                }

            <% } %>

            <% if( (model.properties[property].type === "string" || model.properties[property].type === "date") && property !== "id") { %>
                private String <%- property %>;
                /* Adding Getter and Setter methods */
                public String get<%- capitalPropertyName %>(){
                    return <%- property %>;
                }

                /* Adding Getter and Setter methods */
                public void set<%- capitalPropertyName %>(String <%- property %>){
                    this.<%- property %> = <%- property %>;
                    //Update hashMap value..
                    hashMap.put("<%- property %>", <%- property %>);
                }

            <% } else if( (model.properties[property].type === "number" )&& property !== "id") { %>
                private double <%- property %>;
                /* Adding Getter and Setter methods */
                public double get<%- capitalPropertyName %>(){
                    return <%- property %>;
                }

                /* Adding Getter and Setter methods */
                public void set<%- capitalPropertyName %>(double <%- property %>){
                    this.<%- property %> = <%- property %>;
                    //Update hashMap value..
                    hashMap.put("<%- property %>", <%- property %>);
                }

            <% } else if( model.properties[property].type === "object" && property !== "id" ) { %>
                private Map<String, Object> <%- property %>;
                /* Adding Getter and Setter methods */
                public Map<String, Object> get<%- capitalPropertyName %>(){
                    return <%- property %>;
                }

                /* Adding Getter and Setter methods */
                public void set<%- capitalPropertyName %>(Map<String, Object> <%- property %>){
                    this.<%- property %> = <%- property %>;
                    //Update Map value..
                    hashMap.put("<%- property %>", <%- property %>);
                }

            <% } else if( model.properties[property].type === "geopoint" ) { %>
                private Map<String, Object> <%- property %> = new HashMap();
                /* Adding Getter and Setter methods */
                public Map<String, Object> get<%- capitalPropertyName %>(){
                    return <%- property %>;
                }
                /* Adding Getter and Setter methods */
                public double get<%- capitalPropertyName %>Latitide(){
                    if(<%- property %> != null){
                        return (Double)<%- property %>.get("lat");
                    }else{
                        return 0;
                    }
                }

                /* Adding Getter and Setter methods */
                public double get<%- capitalPropertyName %>Longitude(){
                    if(<%- property %> != null){
                        return (Double)<%- property %>.get("lng");
                    }else{
                        return 0;
                    }

                }

                /* Adding Getter and Setter methods */
                public void set<%- capitalPropertyName %>(Map<String, Object> <%- property %>){
                    this.<%- property %>.putAll(<%- property %>);
                    //Update Map value..
                    hashMap.put("<%- property %>", <%- property %>);
                }

                /* Adding Getter and Setter methods */
                public void set<%- capitalPropertyName %>(double lat, double lng){
                    this.<%- property %>.put("lat", lat);
                    this.<%- property %>.put("lng", lng);
                    //Update Map value..
                    hashMap.put("<%- property %>", <%- property %>);
                }

            <% } else if( model.properties[property].type === "boolean" ) { %>
                private boolean <%- property %>;
                /* Adding Getter and Setter methods */
                public boolean get<%- capitalPropertyName %>(){
                    return <%- property %>;
                }

                /* Adding Getter and Setter methods */
                public void set<%- capitalPropertyName %>(boolean <%- property %>){
                    this.<%- property %> = <%- property %>;
                    //Update hashMap value..
                    hashMap.put("<%- property %>", <%- property %>);
                }

            <% } %>
            <%# else {
                //console.log("ANY", property, model.properties[property]);
                var type;
                if(typeof model.properties[property].type === "function") {

                  if (model.properties[property].type.name === "String") {
                    type = "String";
                  }
                  else if (model.properties[property].type.name === "ObjectID") {
                    type = "Object";
                  }
                  else if (model.properties[property].type.name === "Number") {
                    type = "double";
                  }
                  else if (model.properties[property].type.name === "Date") {
                    type = "String";
                  }else if (model.properties[property].type.name === "Boolean") {
                    type = "Boolean";
                  }else{
                      type = "Object";
                  }
                }else{
                  if(model.properties[property] === "string" || model.properties[property] === "any" || model.properties[property] === "String"){
                    type= "String";
                  }
                  else if (model.properties[property] === "number") {
                    type =  "double";
                  }
                  else if (model.properties[property] === "object") {
                    type =  "Map<String,  ? extends Object>"
                  }
                  else if (model.properties[property] === "boolean") {
                    type =  "Boolean"
                  }
                  else if(model.properties[property] === "geopoint"){
                    type =  "Map<String, Object>"
                  }
                  else {
                    type = "Object";
                  }
                }

            %>
        <% } %>
    <% } %>


    //------------------------------------Database Method---------------------------------------------------


    public void save(final com.strongloop.android.loopback.callbacks.VoidCallback callback){
      //Save to database..
      save__db();
      //Also save to database..
      super.save(callback);
    }

    public void destroy(final com.strongloop.android.loopback.callbacks.VoidCallback callback){
      <%- modelName %>Repository lowercaseFirstLetterRepository = (<%- modelName %>Repository) getRepository();
      if(lowercaseFirstLetterRepository.isSTORE_LOCALLY()){
          //Delete from database..
          String id = getId().toString();
          if(id != null){
             lowercaseFirstLetterRepository.getDb().delete__db(id);
          }
      }
      //Also save to database..
      super.save(callback);
    }



    public void save__db(String id){
      <%- modelName %>Repository lowercaseFirstLetterRepository = (<%- modelName %>Repository) getRepository();

      if(lowercaseFirstLetterRepository.isSTORE_LOCALLY()){
        if(id != null){
          lowercaseFirstLetterRepository.getDb().upsert__db(id, this);
        }
      }
    }


    public void delete__db(){
      <%- modelName %>Repository lowercaseFirstLetterRepository = (<%- modelName %>Repository) getRepository();
      if(lowercaseFirstLetterRepository.isSTORE_LOCALLY()){

        if(getId() != null){
            String id = getId().toString();
          lowercaseFirstLetterRepository.getDb().delete__db(id);
        }
      }
    }


    public void save__db(){
      if(getId() == null){
        return;
      }
      String id = getId().toString();
      save__db(id);
    }



//-----------------------------------END Database Methods------------------------------------------------


    <%# //Adding a BELONGS TO RELATIONSHIP EXAMPLE
        private Customer customer ;

        public Customer getCustomer() {
            return customer;
        }

        public void setCustomer(Customer customer) {
            this.customer = customer;
        }



        public void setCustomer(HashMap<String, Object> customer) {
            //First create a dummy Repo class object for customer.
            CustomerRepository customerRepository = new CustomerRepository();
            Customer customer1 = customerRepository.createObject(customer);
            addRelation(Customer customer);
            setCustomer(customer1);
        }


        public void addRelation(Customer customer) {
            this.setCustomer(customer);
        }
        //Example ends
    %>




    //Now adding relations between related models
    <% for(var relation in model.relations) { %>
        <% if(model.relations.hasOwnProperty(relation)) {
            var lowercaseRelatedModelName = lowercaseFirstLetter( model.relations[relation].model );
            var capitalcaseRelatedModelName = capitalizeFirstLetter(model.relations[relation].model);
            var capitalcaseRelationName = capitalizeFirstLetter(relation);
            if(model.restDefinition[model.relations[relation].model] !== undefined){
        %>
        <%
            //Prepare method for get foreign key..
            var getForeignKeyName = function(){
               var foreignKey = model.relations[relation].foreignKey;
               if(!foreignKey) {
                  foreignKey = lowercaseRelatedModelName + "Id";
               }
              return foreignKey;
            };
        %>
                <% if(model.relations[relation].type === "belongsTo" || model.relations[relation].type === "hasOne"){ %>
                    //Define belongsTo relation method here..
                    private transient <%- capitalcaseRelatedModelName %>  <%- relation %> ;
                    private String <%- getForeignKeyName() %>;

                    public String get<%- capitalizeFirstLetter(getForeignKeyName()) %>(){
                         return <%- getForeignKeyName() %>;
                    }

                    public void set<%- capitalizeFirstLetter(getForeignKeyName()) %>(Object <%- getForeignKeyName() %>){
                        if(<%- getForeignKeyName() %> != null){
                          this.<%- getForeignKeyName() %> = <%- getForeignKeyName() %>.toString();
                        }
                    }

                    public <%- capitalcaseRelatedModelName %> get<%- capitalcaseRelationName %>() {
                        //Adding database method for fetching from relation if not present..
                        if(<%- relation %> == null){
                          <%- modelName %>Repository <%- lowercaseFirstLetter(modelName) %>Repository = (<%- modelName %>Repository) getRepository();

                          RestAdapter restAdapter = <%- lowercaseFirstLetter(modelName) %>Repository.getRestAdapter();
                          if(restAdapter != null){
                            //Fetch locally from db
                            <%- relation %> = get<%- capitalcaseRelationName %>__db(restAdapter);
                          }
                        }
                        return <%- relation %>;
                    }

                    public void set<%- capitalcaseRelationName %>(<%- capitalcaseRelatedModelName %> <%- relation %>) {
                        this.<%- relation %> = <%- relation %>;
                    }

                    //Adding related model automatically in case of include statement from server..
                    public void set<%- capitalcaseRelationName %>(Map<String, Object> <%- relation %>) {
                        //First create a dummy Repo class object for customer.
                        <%- capitalcaseRelatedModelName %>Repository <%- relation %>Repository = new <%- capitalcaseRelatedModelName %>Repository();
                        <%- capitalcaseRelatedModelName %> <%- relation %>1 = <%- relation %>Repository.createObject(<%- relation %>);
                        set<%- capitalcaseRelationName %>(<%- relation %>1);
                    }

                    //Adding related model automatically in case of include statement from server..
                    public void set<%- capitalcaseRelationName %>(HashMap<String, Object> <%- relation %>) {
                        //First create a dummy Repo class object for customer.
                        <%- capitalcaseRelatedModelName %>Repository <%- relation %>Repository = new <%- capitalcaseRelatedModelName %>Repository();
                        <%- capitalcaseRelatedModelName %> <%- relation %>1 = <%- relation %>Repository.createObject(<%- relation %>);
                        set<%- capitalcaseRelationName %>(<%- relation %>1);
                    }

                    //Adding relation method..
                    public void addRelation(<%- capitalcaseRelatedModelName %> <%- relation %>) {
                        that.set<%- capitalcaseRelationName %>(<%- relation %>);
                    }


                    //Fetch related data from local database if present a <%- getForeignKeyName() %> identifier as property for belongsTo
                    public <%- capitalcaseRelatedModelName %> get<%- capitalcaseRelationName %>__db(RestAdapter restAdapter){
                      if(<%- getForeignKeyName() %> != null){
                        <%- capitalcaseRelatedModelName %>Repository <%- relation %>Repository = restAdapter.createRepository(<%- capitalcaseRelatedModelName %>Repository.class);
                           <%- modelName %>Repository lowercaseFirstLetterRepository = (<%- modelName %>Repository) getRepository();
                          if(lowercaseFirstLetterRepository.isSTORE_LOCALLY()){
                                Context context = lowercaseFirstLetterRepository.getContext();
                                if(context != null){
                                    <%- relation %>Repository.addStorage(context);
                                    <%- capitalcaseRelatedModelName %> <%- relation %> = (<%- capitalcaseRelatedModelName %>) <%- relation %>Repository.getDb().get__db(<%- getForeignKeyName() %>);
                                    return <%- relation %>;
                                }else{
                                    return null;
                                }
                          }else{
                            return null;
                          }
                        }else{
                          return null;
                      }
                    }
                <% }%>

                <% if (model.relations[relation].type === "hasMany") { %>
                    <%# In case of hasMany || hasManyThrough || hasAndBelongsToMany %>
                    //Define hasMany relation method here..
                    private transient DataList<<%- capitalcaseRelatedModelName %>>  <%- relation %> ;

                    public DataList< <%- capitalcaseRelatedModelName %> > get<%- capitalcaseRelationName %>() {
                        //Check for pure case of hasMany
                        <% if(!model.relations[relation].through){ -%>
                            if(that.getId() != null){
                                   //TODO: Modify foreign key name..
                                   <%- capitalcaseRelatedModelName %>Repository <%- lowercaseFirstLetter(capitalcaseRelatedModelName) %>Repository = (<%- capitalcaseRelatedModelName %>Repository) getRepository();

                                 //Fetch locally from db
                                 //<%- relation %> = get<%- capitalcaseRelationName %>__db(restAdapter);
                                 // Getting single cont
                                 <%- relation %> = <%- lowercaseFirstLetter(capitalcaseRelatedModelName) %>Repository.getDb().getAll__db("<%- lowercaseFirstLetter(modelName) %>Id", that.getId().toString());

                                 //lowercaseFirstLetter(modelName)
                            }
                        <%}-%>
                        return <%- relation %>;
                    }

                    public void set<%- capitalcaseRelationName %>(DataList<<%- capitalcaseRelatedModelName %>> <%- relation %>) {
                        boolean hashType = false;
                        DataList<HashMap<String, Object>> hashMaps = new DataList<>();
                        for(Object o: <%- relation %>){
                            if(o.getClass().equals(HashMap.class)){
                                hashType = true;
                                HashMap<String, Object> dataObj = (HashMap<String, Object>)o;
                                hashMaps.add(dataObj);
                            }
                        }

                        if(hashType){
                            set<%- capitalcaseRelationName %>1(hashMaps);
                        }else{
                            this.<%- relation %> = <%- relation %>;
                            //TODO: Warning move this to new thread
                            for(<%- capitalcaseRelatedModelName %> data: <%- relation %>){
                              try{
                                data.save__db();
                              } catch (NoSuchMethodError e) {
                                // ignore
                              }
                            }
                        }
                    }

                /*    //Adding related model automatically in case of include statement from server.. Adding 1 for removing same name error..
                    public void set<%- capitalcaseRelationName %>1(List<Map<String, Object>> <%- relation %>) {
                        //First create a dummy Repo class object for ..
                        <%- capitalcaseRelatedModelName %>Repository <%- relation %>Repository = new <%- capitalcaseRelatedModelName %>Repository();
                        List<<%- capitalcaseRelatedModelName %>> result = new ArrayList<>();
                        for (Map<String, Object> obj : <%- relation %>) {
                            //Also add relation to child type for two way communication..
                            <%- capitalcaseRelatedModelName %> obj1 = <%- relation %>Repository.createObject(obj);
                            result.add(obj1);

                        }
                        set<%- capitalcaseRelationName %>(result);

                    }

                */

                    //Adding related model automatically in case of include statement from server.. Adding 1 for removing same name error..
                    public void set<%- capitalcaseRelationName %>1(DataList<HashMap<String, Object>> <%- relation %>) {
                        //First create a dummy Repo class object for ..
                        <%- capitalcaseRelatedModelName %>Repository <%- relation %>Repository = new <%- capitalcaseRelatedModelName %>Repository();
                        DataList<<%- capitalcaseRelatedModelName %>> result = new DataList<>();
                        for (HashMap<String, Object> obj : <%- relation %>) {
                            //Also add relation to child type for two way communication..
                            <%- capitalcaseRelatedModelName %> obj1 = <%- relation %>Repository.createObject(obj);
                            result.add(obj1);

                        }
                        set<%- capitalcaseRelationName %>(result);

                    }


                    //Adding relation method..
                    //Add a dummy class Name object to seperate data..
                    public void addRelation(DataList<<%- capitalcaseRelatedModelName %>> <%- relation %>, <%- capitalcaseRelatedModelName %> dummyClassInstance) {
                        that.set<%- capitalcaseRelationName %>(<%- relation %>);

                    }

                    //Adding relation method..
                    //This will add a new data to the list relation object..
                    public void addRelation(<%- capitalcaseRelatedModelName %> <%- relation %>) {
                        try{
                            try{

                                  //Save to database..
                                  <%- relation %>.save__db();
                            }catch (NoSuchMethodError e) {
                              // ignore
                            }
                            that.get<%- capitalcaseRelationName %>().add(<%- relation %>);
                        }catch(Exception e){
                            DataList< <%- capitalcaseRelatedModelName %>> <%- relation %>1 = new DataList();
                            //Now add this item to list..
                            <%- relation %>1.add(<%- relation %>);
                            //Now set data....
                            that.set<%- capitalcaseRelationName %>(<%- relation %>1);
                        }
                    }




                    <%
                    //Now checking for hasManyThrough relationship..
                    if(model.relations[relation].through){
                        var capitalcaseRelatedModelName = capitalizeFirstLetter(model.relations[relation].through);
                        var throughRelation = lowercaseFirstLetter(model.relations[relation].through);
                    %>
                        //Write hasManyThrough def too..
                        private transient DataList<<%- capitalcaseRelatedModelName %>>  <%- throughRelation %> ;

                        public DataList<<%- capitalcaseRelatedModelName %>> get<%- capitalcaseRelatedModelName %>() {
                            return <%- throughRelation %>;
                        }

                        public void set<%- capitalcaseRelatedModelName %>(DataList<<%- capitalcaseRelatedModelName %>> <%- throughRelation %>) {
                            this.<%- throughRelation %> = <%- throughRelation %>;

                        }

                        //Adding throughRelation method..
                        //Add a dummy class Name object to seperate data..
                        public void addRelation(DataList<<%- capitalcaseRelatedModelName %>> <%- throughRelation %>, <%- capitalcaseRelatedModelName %> dummyClassInstance) {
                            that.set<%- capitalcaseRelatedModelName %>(<%- throughRelation %>);

                        }

                        //Adding throughRelation method..
                        //This will add a new data to the list throughRelation object..
                        public void addRelation(<%- capitalcaseRelatedModelName %> <%- throughRelation %>) {
                            try{
                                that.get<%- capitalcaseRelatedModelName %>().add(<%- throughRelation %>);
                            }catch(Exception e){
                                DataList< <%- capitalcaseRelatedModelName %>> <%- throughRelation %>1 = new DataList();
                                //Now add this item to list..
                                <%- throughRelation %>1.add(<%- throughRelation %>);
                                //Now set data....
                                that.set<%- capitalcaseRelatedModelName %>(<%- throughRelation %>1);
                            }
                        }


                    <% }else{ %>
                        //Implement logic for pure hasMany methods here....

                    <%}%>
                <% } %>
                <% if (model.relations[relation].type === "hasAndBelongsToMany") { %>
                    //TODO ADD BACKWARD COMPATIBILITY FOR hasManyThrough relationship..warning backward compatibility may leads to cyclic error..
                    //Define belongsTo relation method here..
                    private transient DataList<<%- capitalcaseRelatedModelName %>>  <%- relation %> ;

                    public DataList<<%- capitalcaseRelatedModelName %>> get<%- capitalcaseRelationName %>() {
                        return <%- relation %>;
                    }


                    public void set<%- capitalcaseRelationName %>(DataList<<%- capitalcaseRelatedModelName %>> <%- relation %>) {
                        boolean hashType = false;
                        DataList<HashMap<String, Object>> hashMaps = new DataList<>();
                        for(Object o: <%- relation %>){
                            if(o.getClass().equals(HashMap.class)){
                                hashType = true;
                                HashMap<String, Object> dataObj = (HashMap<String, Object>)o;
                                hashMaps.add(dataObj);
                            }else if(o.getClass().equals(HashMap.class)){
                                hashType = true;
                                HashMap<String, Object> dataObj = (HashMap<String, Object>)o;
                                hashMaps.add(dataObj);
                            }
                        }

                        if(hashType){
                            set<%- capitalcaseRelationName %>1(hashMaps);
                        }else{
                            this.<%- relation %> = <%- relation %>;
                        }
                    }

                    /*

                    //Adding related model automatically in case of include statement from server..
                    public void set<%- capitalcaseRelationName %>1(List<Map<String, Object>> <%- relation %>) {
                        //First create a dummy Repo class object for ..
                        <%- capitalcaseRelatedModelName %>Repository <%- relation %>Repository = new <%- capitalcaseRelatedModelName %>Repository();
                        List<<%- capitalcaseRelatedModelName %>> result = new ArrayList<>();
                        for (Map<String, Object> obj : <%- relation %>) {
                            //Also add relation to child type for two way communication..
                            <%- capitalcaseRelatedModelName %> obj1 = <%- relation %>Repository.createObject(obj);
                            result.add(obj1);
                        }
                        set<%- capitalcaseRelationName %>(result);
                    }

                    */

                    //Adding related model automatically in case of include statement from server..
                    public void set<%- capitalcaseRelationName %>1(DataList<HashMap<String, Object>> <%- relation %>) {
                        //First create a dummy Repo class object for ..
                        <%- capitalcaseRelatedModelName %>Repository <%- relation %>Repository = new <%- capitalcaseRelatedModelName %>Repository();
                        DataList<<%- capitalcaseRelatedModelName %>> result = new DataList<>();
                        for (HashMap<String, Object> obj : <%- relation %>) {
                            //Also add relation to child type for two way communication..
                            <%- capitalcaseRelatedModelName %> obj1 = <%- relation %>Repository.createObject(obj);
                            result.add(obj1);
                        }
                        set<%- capitalcaseRelationName %>(result);
                    }


                    //Adding relation method..
                    public void addRelation(DataList<<%- capitalcaseRelatedModelName %>> <%- relation %>, <%- capitalcaseRelatedModelName %> dummyClassInstance) {
                        that.set<%- capitalcaseRelationName %>(<%- relation %>);
                    }


                    //Adding relation method..
                    //This will add a new data to the list relation object..
                    public void addRelation(<%- capitalcaseRelatedModelName %> <%- relation %>) {
                        try{
                            that.get<%- capitalcaseRelationName %>().add(<%- relation %>);
                        }catch(Exception e){
                            DataList< <%- capitalcaseRelatedModelName %>> <%- relation %>1 = new DataList();
                            //Now add this item to list..
                            <%- relation %>1.add(<%- relation %>);
                            //Now set data....
                            that.set<%- capitalcaseRelationName %>(<%- relation %>1);
                        }
                    }

                <% } %>







                    //Now add instance methods to fetch the related belongsTo Model..
                    <%#
                        1) Find the searched model definition first..
                        2) Find the method obj.
                        2) Find the relation name from the model relation obj.
                        //Now start adding server fetching data relations..
                            /*{
                                "fullName": "Recipe.prototype.__get__customer",
                                "name": "prototype.__get__customer",
                                "accepts": [{
                                    "arg": "id",
                                    "type": "any",
                                    "required": true,
                                    "http": {
                                        "source": "path"
                                    },
                                    "description": "PersistedModel id"
                                }, {
                                    "arg": "refresh",
                                    "type": "boolean",
                                    "http": {
                                        "source": "query"
                                    }
                                }],
                                "returns": [{
                                    "arg": "customer",
                                    "type": "Customer",
                                    "root": true
                                }],
                                "errors": [],
                                "description": "Fetches belongsTo relation customer.",
                                "documented": true,
                                "routes": [{
                                    "path": "/:id/customer",
                                    "verb": "get"
                                }],
                                "internal": "Use Recipe.customer() instead."
                            }*/
                    %>

                    <%
                        var modelDef  = model.restDefinition[modelName];
                            //console.log(model.restDefinition);
                        if(modelDef){
                            var restMethods = model.restDefinition[modelName].methods;
                            var modelRelationName = relation;
                            //Now run a loop and find the prototype model definition with same name..
                            restMethods.forEach(function(method){
                                //Str is like prototype.__get__priorities
                                //match prototype.__get__
                                var patt = /prototype\.\_\_[a-zA-Z]+\_\_/;
                                //match prototype.__get__priorities
                                var patt1 = /prototype\.\_\_[a-zA-Z]+\_\_.+/;
                                //match prototype.__
                                var methodPatt = /prototype\.\_\_/;

                                if(patt1.test(method.name)){
                                    //Now get the new str.
                                    var searchRelationName = method.name.replace(patt, "");

                                    if(searchRelationName === modelRelationName){
                                        var methodName = method.name.replace(methodPatt, "");
                                        var methodString = "public void " + methodName + "(";
                                        //Now run a loop of arguments..
                                        method.accepts.forEach(function(argumentObj, index){
                                            var argumentName   = argumentObj.arg;
                                            var argumentType   = argumentObj.type;

                                            if(argumentType === "any"){
                                                argumentType = "string";
                                            }

                                            var argumentSource;
                                            if(argumentObj.http !== undefined){
                                                argumentSource = argumentObj.http.source;
                                            }else{
                                                argumentSource = null;
                                            }


                                            //Checking if the argument is internal or not..
                                            var internalArgument = isInternalArgument(argumentObj, argumentName, method);

                                            var type;
                                            var hasAndBelongsToType;

                                            if(!internalArgument ){
                                                if(argumentType  instanceof Array){
                                                    hasAndBelongsToType = checkHasAndBelongsToDataType(argumentType[0], model);
                                                    argumentType = "DataList<" + convertType(argumentType[0], model) + ">" ;

                                                    type = argumentType;
                                                }
                                                else {
                                                    hasAndBelongsToType = checkHasAndBelongsToDataType(argumentType, model);
                                                    argumentType = convertType(argumentType, model);
                                                    type = argumentType;
                                                }


                                                //console.log("Now checking hasAndBelongsTo type");
                                                //Ignore hasAndBelongsToMany
                                                if(hasAndBelongsToType === false){
                                                    //console.log("i am here");
                                                    //If type belongs to hasAndBelongsToMany then ignore the type and argument..
                                                    //TODO RIGHT NOW I AM IGNORING TYPE LIKE RECIPECATEGORY which belongs to hasAndBelongsTo Many type in future you can add..
                                                    //Add it later in else..



                                                    methodString = methodString + " " +argumentType + " " + argumentName +", ";
                                                }

                                            }
                                        });//arguments loop ends..

                                        var callback ;
                                        var returnType;
                                        var callbackType;
                                        var type;
                                        if(method.returns.length){
                                            if(method.returns[0].type instanceof Array){
                                                type = convertType(method.returns[0].type[0], model);
                                                if(model.allModels[type] !== undefined){
                                                    returnType = "DataList<" + type + ">";
                                                    methodString = methodString + " " + "RestAdapter restAdapter" + ", " +  "final DataListCallback<" + type + "> callback)";
                                                    callback = "DataListCallback<" + type + "> ";
                                                    callbackType = "DataListCallback";
                                                }else{
                                                    returnType = type;
                                                    //methodString = methodString  + " " + " RestAdapter restAdapter" + ", " +  "final Adapter.JsonArrayCallback callback)";
                                                    methodString = methodString  + " " + " RestAdapter restAdapter" + ", " +  "final ObjectCallback<JSONArray>  callback)";
                                                    //callback = "Adapter.JsonArrayCallback";
                                                    callback = "ObjectCallback<JSONArray>";
                                                    callbackType = "DataListCallback";
                                                }
                                            }else{

                                                type = convertType(method.returns[0].type, model);

                                                if(model.allModels[type] !== undefined){
                                                    returnType = type;
                                                    methodString = methodString + " " + "RestAdapter restAdapter" + ", " +  "final ObjectCallback<" + type + "> callback)";
                                                    callback = "ObjectCallback<" + type + "> ";
                                                    callbackType = "ObjectCallback";
                                                }else{
                                                    returnType = type;
                                                    //methodString = methodString + " RestAdapter restAdapter" + ", " + "final Adapter.JsonObjectCallback  callback )";
                                                    methodString = methodString + " RestAdapter restAdapter" + ", " + "final ObjectCallback<JSONObject>  callback)";

                                                    //callback = "Adapter.JsonObjectCallback";
                                                    callback = "ObjectCallback<JSONObject>";
                                                    callbackType = "ObjectCallback";
                                                }
                                            }
                                        }else{
                                            methodString = methodString + " " + "RestAdapter restAdapter" + ", " +  "final VoidCallback callback)";
                                            callback = "VoidCallback ";
                                            //returnType = type;
                                            callbackType = "VoidCallback";
                                        }


                    %>

                                    //Write the method here..
                                    <%- methodString %> {
                                        //Call the onBefore callback method..
                                        callback.onBefore();

                                        //Define methods here..
                                        final <%- modelName %>Repository  <%- lowercaseFirstLetter(modelName) %>Repo = restAdapter.createRepository(<%- modelName %>Repository.class);
                                        <%
                                            var methodArguments = "";
                                            //Now run a loop of arguments..

                                            method.accepts.forEach(function(argumentObj, index){
                                                var argumentName   = argumentObj.arg;
                                                var argumentType   = argumentObj.type;
                                                if(argumentType === "any"){
                                                    argumentType = "string";
                                                }


                                                var argumentSource;
                                                if(argumentObj.http !== undefined){
                                                    argumentSource = argumentObj.http.source;
                                                }else{
                                                    argumentSource = null;
                                                }
                                                //Checking if the argument is internal or not..
                                                var internalArgument = isInternalArgument(argumentObj, argumentName, method);
                                                var isArray = false;
                                                var isCustomClass = false;
                                        %>
                                        <%
                                                if(!internalArgument ){
                                                    var hasAndBelongsToType;

                                                    if(argumentType  instanceof Array){
                                                        hasAndBelongsToType = checkHasAndBelongsToDataType(argumentType[0], model);
                                                        argumentType = "DataList<" + convertType(argumentType[0], model) + ">" ;
                                                        isArray = true;

                                                        if(model.restDefinition[argumentType[0]] !== undefined){
                                                            isCustomClass = true;
                                                        }
                                                    }
                                                    else {
                                                        hasAndBelongsToType = checkHasAndBelongsToDataType(argumentType, model);
                                                        argumentType = convertType(argumentType, model);
                                                        isArray = false;
                                                        if(model.restDefinition[argumentType] !== undefined){
                                                            isCustomClass = true;
                                                        }
                                                    }
                                        %>
                                        <%          if(!hasAndBelongsToType){
                                                        if(isCustomClass){
                                                            if(isArray){
                                        %>
                                                                DataList<Map<String, Object>> objects = new DataList<>();
                                                                for(<%- argumentType[0] %> object : <%- argumentName %>){
                                                                    objects.add(object.convertMap());
                                                                }
                                                                //Add this converted hasMap to argument...
                                                                <% methodArguments = methodArguments + " objects " + ", "; %>
                                        <%                  }else{
                                                                methodArguments = methodArguments + argumentName + ".convertMap(), ";
                                                            }
                                                        }else{
                                                            methodArguments = methodArguments + argumentName + ", ";
                                                        }
                                                    }else{
                                                        //Do nothing
                                                    }
                                        %>
                                        <%

                                                }else{

                                                    //Add internal arguments here..
                                                    methodArguments = methodArguments + " (String)that." + "get" + capitalizeFirstLetter(argumentName) + "(), ";
                                                }
                                            });//arguments loop ends..
                                        %>



                                        <%- lowercaseFirstLetter(modelName) %>Repo.<%- methodName %>(<%- methodArguments %> new <%- callback %>(){
                                            <% if(callbackType === "VoidCallback"){ %>
                                                @Override
                                                public void onSuccess() {
                                                    callback.onSuccess();
                                                    //Calling the finally..callback
                                                    callback.onFinally();
                                                }
                                            <% } %>

                                            <% if(callbackType === "ObjectCallback"){ %>
                                                @Override
                                                <% if(callback !== "ObjectCallback<JSONObject>" ) { %>
                                                    public void onSuccess(<%- returnType %> object) {
                                                        if(object != null){
                                                            //now add relation to this recipe.
                                                            addRelation(object);
                                                            //Also add relation to child type for two way communication..Removing two way communication for cyclic error
                                                            //object.addRelation(that);
                                                            callback.onSuccess(object);
                                                            //Calling the finally..callback
                                                            callback.onFinally();
                                                        }else{
                                                            callback.onSuccess(null);
                                                            //Calling the finally..callback
                                                            callback.onFinally();
                                                        }

                                                    }
                                                <% }else{ %>
                                                    public void onSuccess(JSONObject object) {
                                                        callback.onSuccess(object);
                                                        //Calling the finally..callback
                                                        callback.onFinally();
                                                    }
                                                <% } %>
                                            <% } %>


                                            <% if(callbackType === "DataListCallback"){ %>
                                                @Override
                                                <% if( callback !== "ObjectCallback<JSONArray>" ) {%>
                                                    public void onSuccess(<%- returnType %> object) {
                                                        if(object != null){
                                                            //now add relation to this recipe.
                                                            <%- type %> obj = new <%- type %>();
                                                            addRelation(object, obj);
                                                            //Disabling two way communication for cyclic error..
                                                            /*for (<%- type %> obj : object) {
                                                                //Also add relation to child type for two way communication..
                                                                obj.addRelation(that);
                                                            }*/

                                                            callback.onSuccess(object);
                                                            //Calling the finally..callback
                                                            callback.onFinally();
                                                        }else{
                                                            callback.onSuccess(null);
                                                            //Calling the finally..callback
                                                            callback.onFinally();
                                                        }

                                                    }
                                                <% }else{ %>
                                                    public void onSuccess(JSONArray object) {
                                                        callback.onSuccess(object);
                                                        //Calling the finally..callback
                                                        callback.onFinally();
                                                    }
                                                <% } %>
                                            <% } %>

                                            @Override
                                            public void onError(Throwable t) {
                                                //Now calling the callback
                                                callback.onError(t);
                                                //Calling the finally..callback
                                                callback.onFinally();
                                            }

                                        });
                                    } //method def ends here.
                                <% } %> <%# if method is prototype.__ %>
                            <% } %>
                        <% }); %>
                    <% } %>

                <%# removed section.. if for belongsTo checking belongsTo method if %>

                <% if(model.relations[relation].type === "hasMany" || model.relations[relation].type === "hasManyThrough") { %>
                    //Define hasMany, hasManyThrough method here..

                <% } %> <%# If for hasMany %>
                <% if(model.relations[relation].type === "hasAndBelongsToMany") { %>
                    //Define hasAndBelongsToMany..

                <% } %> <%# If for hasAndBelongsToMany %>
            <% } %> <%# if for checking if model is not undefined %>
        <% } %>  <%# if ends for hasOwnProperty check. %>
    <% } %>  <%# for loop ends for models %>

}
